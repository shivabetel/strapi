const { default: entityService } = require('@strapi/strapi/lib/services/entity-service');
const get = require('lodash/get')
const has = require('lodash/has')
const isArray = require('lodash/isArray')
const omit = require("lodash/omit");



class ContentMigrationError extends Error {
    constructor(message, stacktrace) {
        super(message);
        // this.name = "ValidationError";
        this.type = 'ERROR_CONTENT_MIGRATION';
        this.stacktrace = stacktrace;
    }
}



const checkForParentContentTypes = async (searchModelId) => {
    try{
        const allComponents = strapi.components;
        const contentTypes = strapi.contentTypes;
        const contentTypeService = await strapi.plugin('content-type-builder').service("content-types")
        const userDefinedContentTypes = Object.keys(strapi.contentTypes)
            .map(uid => contentTypeService.formatContentType(strapi.contentTypes[uid]))
            .filter((model) => !model.plugin)
        function checkForParentContentTypeRecursively() {
           
            const getType = (schema, attrName) => get(schema, ["attributes", attrName, "type"]);
            const getTarget = (schema, attrName) => get(schema, ["attributes", attrName, "target"])
            const getOtherInfos = (schema, arr) => get(schema, ['attributes', ...arr], '');
            const recursive = (schema) => {
                try{
                    return Object.keys(schema['attributes']).reduce((acc, current) => {
                        const attrType = getType(schema, current);
                        const target = getTarget(schema, current)
                        let value;
                        if (target && target !== searchModelId) {
                            //these are parent entities as it reference to these entities via fk.
                            userDefinedContentTypes.find(obj => obj['uid'] == target) && (value = {
                                modelId: target,
                                key: current
                            });//it should be only used defined stypes not generated by starpi - not considering it yet
        
                        }
                        if (attrType == 'component') {
                            const componentUid = getOtherInfos(schema, [current, 'component']);
                            value = recursive(allComponents[componentUid]).flatMap(value => value)
                        }
                        if (attrType == 'dynamiczone') {
                            const components = getOtherInfos(schema, [current, 'components'])
                            value = components.map(componentUid => recursive(allComponents[componentUid]).flatMap(value => value)).flatMap(value => value)
                        }
        
                        return [
                            ...acc,
                            value
                        ]
        
                    }, [])
                }catch(err){
                    new ContentMigrationError('Error while fetching parent content types:',err)
                }
                
            }
            return recursive(contentTypes[searchModelId]).flatMap(value => value);
    
        }
    
        return checkForParentContentTypeRecursively().flatMap(value => value).filter(Boolean);
    }catch(err){
        if(err instanceof ContentMigrationError){
            throw err
        }
        throw new ContentMigrationError('something went wrong while fetching parent content types:',err)
    }

    


}



const checkForChildContentTypes = async (searchModelId) => {

    const allComponents = strapi.components;
    const contentTypeService = await strapi.plugin('content-type-builder').service("content-types")
    const contentTypes = Object.keys(strapi.contentTypes)
        .map(uid => contentTypeService.formatContentType(strapi.contentTypes[uid]))
        .filter((model) => !model.plugin)

    return contentTypes.map(contentType => ({
        contentType,
        result: checkForChildContentTypeRecursively(contentType['schema'], allComponents).flatMap(value => value).filter(Boolean)
    })).filter(({ result }) => result.some(Boolean))

    function checkForChildContentTypeRecursively(contentType) {
        const getType = (schema, attrName) => get(schema, ["attributes", attrName, "type"])
        const getTarget = (schema, attrName) => get(schema, ["attributes", attrName, "target"])
        const getOtherInfos = (schema, arr) => get(schema, ['attributes', ...arr], '');
        const recursive = (schema) => {
            return Object.keys(schema['attributes']).reduce((acc, current) => {
                const attrType = getType(schema, current)
                const target = getTarget(schema, current)

                //  const isRepeatable = getOtherInfos(schema, [current, 'repeatable']);
                let value = false
                if (target === searchModelId) {
                    value = true
                }
                if (attrType == 'component') {
                    const component = getOtherInfos(schema, [current, 'component']);
                    value = recursive(allComponents[component]).flatMap(value => value)
                }
                if (attrType == 'dynamiczone') {
                    const components = getOtherInfos(schema, [current, 'components'])
                    value = components.map(component => recursive(allComponents[component]).flatMap(value => value))
                }

                // acc[current] = value;
                return [
                    ...acc,
                    value
                ];

            }, [])
        }

        return recursive(contentType).flatMap(value => value)
    }






}


const getAllFilesInTheEntity = (retrievedData, currentSchema) => {

  const componentsSchema = strapi.components;

    function getAllFilesRecursively(){
        const getType = (schema, attrName) => get(schema, ['attributes', attrName, 'type'], '');
        const getOtherInfos = (schema, arr) => get(schema, ['attributes', ...arr], '');
    
        const recursive = (data, schema) => {
            return Object.keys(data).reduce((acc, current) => {
                const attrType = getType(schema, current);
                const value = get(data, current);
                const component = getOtherInfos(schema, [current, 'component']);
                const isRepeatable = getOtherInfos(schema, [current, 'repeatable']);
                let files;
    
                switch (attrType) {                                        
                    case 'media':
                        if (getOtherInfos(schema, [current, 'multiple']) === true) {                        
                            files = value ? value.map(file => file) : []//value ? value.filter(file => !(file instanceof File)) : null;
                        } else {
                            files = value ? [value] : []//get(value, 0) instanceof File ? null : get(value, 'id', null);
                        }
                        break;
                    case 'component':
                        if (isRepeatable) {
                            files = value
                                ? value.flatMap(data => {
                                    const files = recursive(data, componentsSchema[component]);
                                    return files;
                                })
                                : [];
                        } else {
                            files = value ? recursive(value, componentsSchema[component]) : [];
                        }
                        break;
                    case 'dynamiczone':
                        files = value.map(componentData => {
                            const file = recursive(
                                componentData,
                                componentsSchema[componentData.__component]
                            );
    
                            return file;
                        }).flatMap(file => file);
                        break; 
                    default:
                     files = null                      
                }
    
                console.log("files:::",files)

               return files ? [
                    ...acc,
                    ...files
                ] : acc
            }, []);
        };
    
        return recursive(retrievedData, currentSchema);
    }


   return getAllFilesRecursively().filter(Boolean).flatMap(file => file)

   
};


const cleanData = (retrievedData, currentSchema, componentsSchema, parentModelEntitites = [], migratedFileEntities = []) => {
    const getType = (schema, attrName) => get(schema, ['attributes', attrName, 'type'], '');
    const getOtherInfos = (schema, arr) => get(schema, ['attributes', ...arr], '');

    const recursiveCleanData = (data, schema) => {
        return Object.keys(data).reduce((acc, current) => {
            const attrType = getType(schema, current);
            const value = get(data, current);
            const component = getOtherInfos(schema, [current, 'component']);
            const isRepeatable = getOtherInfos(schema, [current, 'repeatable']);
            let cleanedData;

            switch (attrType) {
                case 'json':
                    try {
                        cleanedData = JSON.parse(value);
                    } catch (err) {
                        cleanedData = value;
                    }

                    break;
                // TODO
                // case 'date':
                //   cleanedData =
                //     value && value._isAMomentObject === true ? value.format('YYYY-MM-DD') : value;
                //   break;
                // case 'datetime':
                //   cleanedData = value && value._isAMomentObject === true ? value.toISOString() : value;
                //   break;
                case 'time': {
                    cleanedData = value;

                    // FIXME
                    if (value && value.split(':').length < 3) {
                        cleanedData = `${value}:00`;
                    }

                    break;
                }
                case 'media':
                    if (getOtherInfos(schema, [current, 'multiple']) === true) {                        
                        cleanedData = value ? value.map(file => {
                           const migratedFileEntity =  migratedFileEntities.find(migratedFile => migratedFile['id'] == file['id'])
                           return migratedFileEntity ? helperCleanData(migratedFileEntity, 'newId') : null;
                        }) : null//value ? value.filter(file => !(file instanceof File)) : null;
                    } else {
                        cleanedData = value ? ( () => {
                            const migratedFileEntity =  migratedFileEntities.find(migratedFile => migratedFile['id'] == value['id'])
                            return migratedFileEntity ? helperCleanData(migratedFileEntity, 'newId') : null
                        })() : null//get(value, 0) instanceof File ? null : get(value, 'id', null);
                    }
                    break;
                case 'component':
                    if (isRepeatable) {
                        cleanedData = value
                            ? value.map(data => {
                                const subCleanedData = recursiveCleanData(data, componentsSchema[component]);

                                return subCleanedData;
                            })
                            : value;
                    } else {
                        cleanedData = value ? recursiveCleanData(value, componentsSchema[component]) : value;
                    }
                    break;
                case 'dynamiczone':
                    cleanedData = value.map(componentData => {
                        const subCleanedData = recursiveCleanData(
                            componentData,
                            componentsSchema[componentData.__component]
                        );

                        return subCleanedData;
                    });
                    break;
                default:
                    // The helper is mainly used for the relations in order to just send the id
                    const parentEntity = parentModelEntitites.find(obj => Object.keys(obj)[0] == current)
                    if (parentEntity) {
                        const parentEntityValues = Object.values(parentEntity).flatMap(value => value);
                        if (isArray(value)) {
                            const mappedValues = value.map(obj => {
                                if (obj['id']) {
                                    const entity = parentEntityValues.find(({ id }) => id == obj['id'])
                                    entity && (obj['id'] = entity['newId'])//update the id with the new id created in the target environment
                                }
                                return obj;

                            });
                            cleanedData = helperCleanData(mappedValues, 'id');

                        }
                        if (isObject(value)) {
                            const entity = parentEntityValues.find(({ id }) => id == value['id'])
                            entity &&  (value['id'] = entity['newId'])
                            cleanedData = helperCleanData(value, 'id');
                        }
                    } else
                        cleanedData = helperCleanData(value, 'id');
            }

            acc[current] = cleanedData;

            return acc;
        }, {});
    };

    return recursiveCleanData(retrievedData, currentSchema);
};

const helperCleanData = (value, key) => {
    if (isArray(value)) {
        return value.map(obj => (obj[key] ? obj[key] : obj));
    }
    if (isObject(value)) {
        return value[key];
    }

    return value;
};



const createComponentModel = async (uid) => {
    const allComponents = strapi.components;
    const contentTypes = strapi.contentTypes;
    const contentTypeService = await strapi.plugin('content-type-builder').service("content-types")
    const userDefinedContentTypes = Object.keys(strapi.contentTypes)
        .map(uid => contentTypeService.formatContentType(strapi.contentTypes[uid]))
        .filter((model) => !model.plugin)


    function createComponentModelRecusrively(){
        const getType = (schema, attrName) => get(schema, ["attributes", attrName, "type"])
        const getOtherInfos = (schema, arr) => get(schema, ["attributes", ...arr])
        const recursive = (schema) => {
            return Object.keys(schema['attributes'])
                        .reduce((acc, current) => {
                            const attrType = getType(schema, current)
                            let value;
                            if(attrType === 'component'){
                                const componentUid = getOtherInfos(schema, [current, 'component'])
                                value = recursive(allComponents[componentUid])
                            }
                            if(attrType === 'dynamiczone'){
                               const components =  getOtherInfos(schema, [current, 'components'])
                              value = components.reduce((ac, currentComponentUid) => {
                                  const values = recursive(allComponents[currentComponentUid])
                                return {
                                    ...ac,
                                    ...values
                                }
                              }, {})
    
                            }
                            if(attrType === 'relation'){
                                const modelId = getOtherInfos(schema, [current, 'target'])
                                if (modelId && modelId !== uid) {
                                    //these are parent entities as it reference to these entities via fk.
                                    userDefinedContentTypes.find(obj => obj['uid'] == modelId) && (value = recursive(contentTypes[modelId]));//it should be only used defined stypes not generated by starpi - not considering it yet
                
                                }
                                
                            }
                            if(attrType === 'media'){
                                value = {}
                            }

                           // value =  true;
    
    
                            return {
                                ...acc,
                               [current]: value
                            }
    
                        }, {})
        }

        return recursive(contentTypes[uid])
    }

    return createComponentModelRecusrively()


    

}

const getContentQueryObject = (obj) => {
    let result = []

    Object.keys(obj).forEach((key, index) => {
        if (typeof obj[key] == 'object') {
            result = [
                ...result,
                key,
                ...getContentQueryObject(obj[key]).map(s => `${key}.${s}`)//result.map(s => `${s}.${_getObjectKey(obj[key])}`)
            ]
        }
    })


    return result;

}

function omitDeep(input, props) {
    function omitDeepOnOwnProps(obj) {
        if (typeof input === "undefined") {
            return input;
        }

        if (!Array.isArray(obj) && !isObject(obj)) {
            return obj;
        }

        if (Array.isArray(obj)) {
            return omitDeep(obj, props);
        }

        const o = {};
        for (const [key, value] of Object.entries(obj)) {
            o[key] = !isNil(value) ? omitDeep(value, props) : value;
        }

        return !o['mime'] ? omit(o, props) : o;

        // return omit(o, props);
    }

    if (arguments.length > 2) {
        props = Array.prototype.slice.call(arguments).slice(1);
    }

    if (Array.isArray(input)) {
        return input.map(omitDeepOnOwnProps);
    }

    return omitDeepOnOwnProps(input);
};

function isNil(value) {
    return value === null || value === undefined;
}

function isObject(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
}

module.exports = {
    cleanData,
    createComponentModel,
    getContentQueryObject,
    omitDeep,
    checkForChildContentTypes,
    checkForParentContentTypes,
    ContentMigrationError,
    getAllFilesInTheEntity
}